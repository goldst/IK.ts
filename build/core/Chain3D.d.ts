import { BaseboneConstraintType, ConnectionType } from '../constants';
import { V3 } from '../math/V3';
import { M3 } from '../math/M3';
import { Bone3D } from './Bone3D';
export declare class Chain3D {
    static isChain3D: boolean;
    tmpTarget: V3;
    tmpMtx: M3;
    bones: Bone3D[];
    name: string;
    color: number;
    solveDistanceThreshold: number;
    minIterationChange: number;
    maxIteration: number;
    precision: number;
    chainLength: number;
    numBones: number;
    baseLocation: V3;
    fixedBaseMode: boolean;
    baseboneConstraintType: BaseboneConstraintType;
    baseboneConstraintUV: V3;
    baseboneRelativeConstraintUV: V3;
    baseboneRelativeReferenceConstraintUV: V3;
    lastTargetLocation: V3;
    lastBaseLocation: V3;
    currentSolveDistance: number;
    connectedChainNumber: number;
    connectedBoneNumber: number;
    boneConnectionPoint: ConnectionType;
    isFullForward: boolean;
    embeddedTarget: V3;
    useEmbeddedTarget: boolean;
    constructor(color?: number);
    clone(): Chain3D;
    clear(): void;
    addBone(bone: Bone3D): void;
    removeBone(id: number): void;
    addConsecutiveBone(directionUV: V3, length: number): void;
    addConsecutiveFreelyRotatingHingedBone(directionUV: V3, length: number, type: string, hingeRotationAxis: V3): void;
    addConsecutiveHingedBone(DirectionUV: V3, length: number, type: string, HingeRotationAxis: V3, clockwiseDegs: number, anticlockwiseDegs: number, hingeReferenceAxis: V3): void;
    addConsecutiveRotorConstrainedBone(boneDirectionUV: V3, length: number, constraintAngleDegs: number): void;
    getBoneConnectionPoint(): ConnectionType;
    getConnectedBoneNumber(): number;
    getConnectedChainNumber(): number;
    getBaseboneConstraintType(): BaseboneConstraintType;
    getBaseboneConstraintUV(): V3 | undefined;
    getBaseLocation(): V3;
    getEffectorLocation(): V3;
    getLastTargetLocation(): V3;
    getLiveChainLength(): number;
    getBaseboneRelativeReferenceConstraintUV(): V3;
    setConnectedBoneNumber(boneNumber: number): void;
    setConnectedChainNumber(chainNumber: number): void;
    setBoneConnectionPoint(point: ConnectionType): void;
    setColor(c: number): void;
    setBaseboneRelativeConstraintUV(uv?: V3): void;
    setBaseboneRelativeReferenceConstraintUV(uv: V3): void;
    setBaseboneConstraintUV(uv: V3): void;
    setRotorBaseboneConstraint(type: string, constraintAxis: V3, angleDegs: number): void;
    setHingeBaseboneConstraint(type: string, hingeRotationAxis: V3, cwDegs: number, acwDegs: number, hingeReferenceAxis: V3): void;
    setFreelyRotatingGlobalHingedBasebone(hingeRotationAxis: V3): void;
    setGlobalHingedBasebone(hingeRotationAxis: V3, cwDegs: number, acwDegs: number, hingeReferenceAxis: V3): void;
    setFreelyRotatingLocalHingedBasebone(hingeRotationAxis: V3): void;
    setLocalHingedBasebone(hingeRotationAxis: V3, cwDegs: number, acwDegs: number, hingeReferenceAxis: V3): void;
    setBaseLocation(baseLocation: V3): void;
    setFixedBaseMode(value: boolean): void;
    setMaxIterationAttempts(maxIterations: number): void;
    setMinIterationChange(minIterationChange: number): void;
    setSolveDistanceThreshold(solveDistance: number): void;
    solveForEmbeddedTarget(): number | undefined;
    resetTarget(): void;
    solveForTarget(t: V3): number;
    solveIK(target: V3): number | undefined;
    updateChainLength(): void;
    cloneBones(): Bone3D[];
}
